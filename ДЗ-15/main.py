# 6.
# Дан массив целых чисел,
# отсортируйте массив в порядке
# возрастания в зависимости от
# частоты значений.
#
# Вернуть отсортированный массив.
#
# lst = [2, 1, 2, 2, 1, 3] => [3, 1, 1, 2, 2, 2]

print('\nЗадание 6\n')

lst = [2,1,2,2,1,3]
print('Было: ',lst)

result = []
for i, x in enumerate(lst):
    if i == lst.index(x):
        result.extend([x]*lst.count(x))
print('Стало: ',list(reversed(result))) # Тут я сделал list(reversed()) для того, чтобы правильно выводилось.
# Изначально было вот так [2 2 2 1 1 3], а хотелось сделать как по ТЗ, теперь всё выводится корректно

# 7.

# Вам дан массив nums, состоящий
# из целых положительных чисел.
#
# Вы должны взять каждое целое число
# в массиве, поменять местами его цифры
# и добавить новое число в конец массива.
#
# По итогу надо вернуть количество уникальных
# целых чисел в конечном массиве.

print('\nЗадание 7\n')

lst = [2,3,123,133,33,13,15,2]
lst_result = [2,3,123,133,33,13,15,2] # Добавить в конце того же массива у меня не получилось - я сделал его же копию
# в виде lst_result

for i in range(len(lst)):
    if len(str(lst[i])) == 1:
        lst_result.append(int(lst[i])) # Исходил из такой логики, что если 1 элемент - то и менять ничего не надо
    elif len(str(lst[i])) >= 2:
        lst_result.append(int(''.join(sorted(str(lst[i]), reverse=True)))) # Все элементы, чья длина больше или равно
        # 2, автоматически переворачивались задом наперед

print('\nБыло: ',lst,'\nСтало:',list(set(lst_result))) # В СТАЛО как раз отфильтрованный список вернул без повторов

# 8.

# Дан массив целых чисел nums.
# Верните максимальное значение такое, что:
# (nums[i]-1)*(nums[j]-1).

print('\nЗадание 8\n')

lst = [2,1,2,2,1,3,2,3,123,133,33,13,15,2,1000,2000,1111,2222,1212,2121]
num_1, num_2 = int(lst.pop(lst.index(max(lst)))),int(lst.pop(lst.index(max(lst))))

print('Изначальные значения: ', lst,'\n\nПервое максимальное число: ', num_1, '\nВторое максимальное число: ', num_2)
print('\nОтвет: ',(num_1 - 1) * (num_2 - 1))


